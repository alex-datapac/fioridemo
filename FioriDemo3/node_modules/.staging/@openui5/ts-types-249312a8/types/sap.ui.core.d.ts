/**
 * This is a Beta version of the OpenUI5 TypeScript Signatures.
 * Significant changes may occur in future versions,
 * including potential breaking changes.
 */
// For Library Version: 1.60.14
/**
 * Root namespace for JavaScript functionality provided by SAP SE.
 *
 * The `sap` namespace is automatically registered with the OpenAjax hub if it exists.
 */
declare namespace sap {
  /**
   * The `sap.ui` namespace is the central OpenAjax compliant entry point for UI related JavaScript functionality
   * provided by SAP.
   */
  namespace ui {
    /**
     * @SINCE 1.15.0
     * @deprecated (since 1.56) - use {@link sap.ui.core.Component.get Component.get} or {@link sap.ui.core.Component.create
     * Component.create} instead. Note: {@link sap.ui.core.Component.create Component.create} does not support
     * synchronous loading or the deprecated options ***manifestFirst*** and ***manifestUrl***.
     * @EXPERIMENTAL (since 1.27.0)
     *
     * Creates a new instance of a `Component` or returns the instance of an existing `Component`.
     *
     * If you want to look up an existing `Component` you can call this function with a Component ID as parameter:
     *
     * ```javascript
     *
     *   var oComponent = sap.ui.component(sComponentId);
     * ```
     *
     *
     * To create a new instance of a component you pass a component configuration object into this function:
     *
     * ```javascript
     *
     *   var oComponent = sap.ui.component({
     *     name: "my.Component",
     *     url: "my/component/location",
     *     id: "myCompId1"
     *   });
     * ```
     */
    function component(
      /**
       * ID of an existing Component or the configuration object to create the Component
       */
      vConfig: {
        /**
         * Name of the Component to load, as a dot-separated name; Even when an alternative location is specified
         * from which the manifest should be loaded (e.g. `vConfig.manifest` is set to a non-empty string), then
         * the name specified in that manifest will be ignored and this name will be used instead to determine the
         * module to be loaded.
         */
        name: string;
        /**
         * Alternative location from where to load the Component. If a `manifestUrl` is given, this URL specifies
         * the location of the final component defined via that manifest, otherwise it specifies the location of
         * the component defined via its name `vConfig.name`.
         */
        url?: string;
        /**
         * Initial data of the Component (@see sap.ui.core.Component#getComponentData)
         */
        componentData?: object;
        /**
         * sId of the new Component
         */
        id?: string;
        /**
         * Settings of the new Component
         */
        settings?: object;
        /**
         * Indicates whether the Component creation should be done asynchronously; defaults to true when using the
         * manifest property with a truthy value otherwise the default is false (experimental setting)
         */
        async?: boolean;
        /**
         * Hints for the asynchronous loading (experimental setting)
         */
        asyncHints?: {
          /**
           * Libraries that should be (pre-)loaded before the Component (experimental setting)
           */
          libs?: string[];
          /**
           * Components that should be (pre-)loaded before the Component (experimental setting)
           */
          components?: string[];
          /**
           * @since 1.37.0 a `Promise` or and array of `Promise`s for which the Component instantiation should wait
           * (experimental setting)
           */
          waitFor?: Promise<any> | Promise<any>[];
        };

        /**
         * @since 1.49.0 Controls when and from where to load the manifest for the Component. When set to any truthy
         * value, the manifest will be loaded asynchronously by default and evaluated before the Component controller,
         * if it is set to a falsy value other than `undefined`, the manifest will be loaded after the controller.
         * A non-empty string value will be interpreted as the URL location from where to load the manifest. A non-null
         * object value will be interpreted as manifest content. Setting this property to a value other than `undefined`,
         * completely deactivates the properties `manifestUrl` and `manifestFirst`, no matter what their values
         * are.
         */
        manifest?: boolean | string | object;
        /**
         * @since 1.33.0 Specifies the URL from where the manifest should be loaded from Using this property implies
         * `vConfig.manifestFirst=true`.
         * **DEPRECATED since 1.49.0, use `vConfig.manifest=url` instead!**. Note that this property is ignored
         * when `vConfig.manifest` has a value other than `undefined`.
         */
        manifestUrl?: string;
        /**
         * @since 1.33.0 defines whether the manifest is loaded before or after the Component controller. Defaults
         * to `sap.ui.getCore().getConfiguration().getManifestFirst()`
         * **DEPRECATED since 1.49.0, use `vConfig.manifest=true|false` instead!** Note that this property is ignored
         * when `vConfig.manifest` has a value other than `undefined`.
         */
        manifestFirst?: boolean;
        /**
         * If set to `true` validation of the component is handled by the `MessageManager`
         */
        handleValidation?: string;
      }
    ): sap.ui.core.Component | Promise<any>;
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.Controller.create Controller.create} or {@link
     * sap.ui.core.mvc.Controller.extend Controller.extend} instead.
     *
     * Defines a controller class or creates an instance of an already defined controller class.
     *
     * When a name and a controller implementation object is given, a new controller class of the given name
     * is created. The members of the implementation object will be copied into each new instance of that controller
     * class (shallow copy). **Note**: as the members are shallow copied, controller instances will share all
     * object values. This might or might not be what applications expect.
     *
     * If only a name is given, a new instance of the named controller class is returned.
     */
    function controller(
      /**
       * The controller name
       */
      sName: string,
      /**
       * An object literal defining the methods and properties of the controller
       */
      oControllerImpl: object,
      /**
       * Decides whether the controller gets loaded asynchronously or not
       */
      bAsync: boolean
    ): void | sap.ui.core.mvc.Controller | Promise<any>;
    /**
     * @SINCE 1.27.0
     *
     * Defines a JavaScript module with its ID, its dependencies and a module export value or factory.
     *
     * The typical and only suggested usage of this method is to have one single, top level call to `sap.ui.define`
     * in one JavaScript resource (file). When a module is requested by its module ID for the first time, the
     * corresponding resource is determined from the ID and the current {@link sap.ui.loader.config configuration}.
     * The resource will be loaded and executed which in turn will execute the top level `sap.ui.define` call.
     *
     * If the module ID was omitted from that call, it will be substituted by the ID that was used to request
     * the module. As a preparation step, the dependencies as well as their transitive dependencies, will be
     * loaded. Then, the module value (its export) will be determined: if a static value (object, literal) was
     * given as `vFactory`, that value will be the module value. If a function was given, that function will
     * be called (providing the module exports of the declared dependencies as parameters to the function) and
     * its return value will be used as module export value. The framework internally associates the resulting
     * value with the module ID and provides it to the original requester of the module. Whenever the module
     * is requested again, the same export value will be returned (modules are executed only once).
     *
     * Example:
     *  The following example defines a module, but doesn't hard code the module ID. If stored in a file 'sap/mylib/SomeClass.js',
     * it can be requested with the ID 'sap/mylib/SomeClass'.
     * ```javascript
     *
     *   sap.ui.define(['./Helper', 'sap/m/Bar'], function(Helper,Bar) {
     *
     *     // create a new class
     *     var SomeClass = function() {};
     *
     *     // add methods to its prototype
     *     SomeClass.prototype.foo = function() {
     *
     *         // use a function from the dependency 'Helper' in the same package (e.g. 'sap/mylib/Helper' )
     *         var mSettings = Helper.foo();
     *
     *         // create and return an sap.m.Bar (using its local name 'Bar')
     *         return new Bar(mSettings);
     *
     *     }
     *
     *     // return the class as module value
     *     return SomeClass;
     *
     *   });
     * ```
     *
     *
     * In another module or in an application HTML page, the {@link sap.ui.require} API can be used to load
     * the sap/mylib/Something module and to work with it:
     *
     *
     * ```javascript
     *
     * sap.ui.require(['sap/mylib/Something'], function(Something) {
     *
     *   // instantiate a Something and call foo() on it
     *   new Something().foo();
     *
     * });
     * ```
     *
     *
     * Module Name Syntax:
     *
     * `sap.ui.define` uses a simplified variant of the {@link jQuery.sap.getResourcePath unified resource name}
     * syntax for the module's own name as well as for its dependencies. The only difference to that syntax
     * is, that for `sap.ui.define` and `sap.ui.require`, the extension (which always would be '.js') has to
     * be omitted. Both methods always add this extension internally.
     *
     * As a convenience, the name of a dependency can start with the segment './' which will be replaced by
     * the name of the package that contains the currently defined module (relative name).
     *
     * It is best practice to omit the name of the defined module (first parameter) and to use relative names
     * for the dependencies whenever possible. This reduces the necessary configuration, simplifies renaming
     * of packages and allows to map them to a different namespace.
     *
     * Dependency to Modules:
     *
     * If a dependencies array is given, each entry represents the name of another module that the currently
     * defined module depends on. All dependency modules are loaded before the export of the currently defined
     * module is determined. The module export of each dependency module will be provided as a parameter to
     * a factory function, the order of the parameters will match the order of the modules in the dependencies
     * array.
     *
     * **Note:** The order in which the dependency modules are executed is **not** defined by the order
     * in the dependencies array! The execution order is affected by dependencies between the dependency
     * modules as well as by their current state (whether a module already has been loaded or not). Neither
     * module implementations nor dependents that require a module set must make any assumption about the execution
     * order (other than expressed by their dependencies).
     *
     * **Note:** A static module export (a literal provided to `sap.ui.define`) cannot depend on the module
     * exports of the dependency modules as it has to be calculated before the dependencies are resolved. As
     * an alternative, modules can define a factory function, calculate a static export value in that function,
     * potentially based on the dependencies, and return the result as module export value. The same approach
     * must be taken when the module export is supposed to be a function.
     *
     * Asynchronous Contract:
     *
     * `sap.ui.define` is designed to support real Asynchronous Module Definitions (AMD) in future, although
     * it internally still might use synchronous module loading, depending on configuration and context. However,
     * callers of `sap.ui.define` must never rely on any synchronous behavior that they might observe in a specific
     * test scenario.
     *
     * For example, callers of `sap.ui.define` must not use the module export value immediately after invoking
     * `sap.ui.define`:
     *
     *
     * ```javascript
     *
     *   // COUNTER EXAMPLE HOW __NOT__ TO DO IT
     *
     *   // define a class Something as AMD module
     *   sap.ui.define('Something', [], function() {
     *     var Something = function() {};
     *     return Something;
     *   });
     *
     *   // DON'T DO THAT!
     *   // accessing the class _synchronously_ after sap.ui.define was called
     *   new Something();
     *
     * ```
     *
     *
     * Applications that need to ensure synchronous module definition or synchronous loading of dependencies
     * **MUST** use the deprecated legacy APIs {@link jQuery.sap.declare} and {@link jQuery.sap.require}.
     *
     * (No) Global References:
     *
     * To be in line with AMD best practices, modules defined with `sap.ui.define` should not make any use of
     * global variables if those variables are also available as module exports. Instead, they should add dependencies
     * to those modules and use the corresponding parameter of the factory function to access the module exports.
     *
     * As the current programming model and the documentation of UI5 heavily rely on global names, there will
     * be a transition phase where UI5 enables AMD modules and local references to module exports in parallel
     * to the old global names. The fourth parameter of `sap.ui.define` has been added to support that transition
     * phase. When this parameter is set to true, the framework provides two additional features
     *
     *
     * 	 - Before the factory function is called, the existence of the global parent namespace for the current
     * 			module is ensured
     * 	 - The module export returned by the module's factory function will be automatically exported under
     * 			the global name which is derived from the ID of the module
     *
     * The parameter lets the framework know whether any of those two operations is needed or not. In future
     * versions of UI5, a central configuration option is planned to suppress those 'exports'.
     *
     * Third Party Modules: Although third party modules don't use UI5 APIs, they still can be listed as dependencies
     * in a `sap.ui.define` call. They will be requested and executed like UI5 modules, but to make their exports
     * available, so called ***shims*** have to be defined.
     *
     * Note that UI5 temporarily deactivates an existing AMD loader while it executes third party modules known
     * to support AMD. This sounds contradictorily at a first glance as UI5 wants to support AMD, but for now
     * it is necessary to fully support UI5 applications that rely on global names for such modules.
     *
     * For third-party modules that UI5 delivers (e.g. those in namespace `sap/ui/thirdparty/`), the necessary
     * shims are defined by UI5 itself by executing the private module `ui5loader-autoconfig.js` during bootstrap.
     *
     * Example:
     * ```javascript
     *
     *   // module 'Something' wants to use third party library 'URI.js'
     *   // It is packaged by UI5 as non-UI5-module 'sap/ui/thirdparty/URI'
     *   // the following shim helps UI5 to correctly load URI.js and to retrieve the module's export value
     *   // Apps don't have to define that shim, it is already applied by ui5loader-autconfig.js
     *   sap.ui.loader.config({
     *     shim: {
     *       'sap/ui/thirdparty/URI': {
     *          amd: true, // URI.js reacts on an AMD loader, this flag lets UI5 temp. disable such loaders
     *          exports: 'URI' // name of the global variable under which URI.js exports its module value
     *       }
     *     }
     *   });
     *
     *   // now the module can be retrieved like other modules
     *   sap.ui.define('Something', ['sap/ui/thirdparty/URI'], function(URIModuleValue) {
     *
     *     new URIModuleValue(...); // same as the global 'URI' name: new URI(...)
     *
     *     ...
     *   });
     * ```
     *
     *
     * Differences to Standard AMD:
     *
     * The current implementation of `sap.ui.define` differs from the AMD specification (https://github.com/amdjs/amdjs-api)
     * or from concrete AMD loaders like `requireJS` in several aspects:
     * 	 - The name `sap.ui.define` is different from the plain `define`. This has two reasons: first, it avoids
     * 			the impression that `sap.ui.define` is an exact implementation of an AMD loader. And second, it allows
     * 			the coexistence of an AMD loader (e.g. requireJS) and `sap.ui.define` in one application as long as UI5
     * 			or applications using UI5 are not fully prepared to run with an AMD loader. Note that the difference
     * 			of the API names also implies that the UI5 loader can't be used to load 'real' AMD modules as they expect
     * 			methods `define` and `require` to be available. Modules that use Unified Module Definition (UMD) syntax,
     * 			can be loaded, but only when no AMD loader is present or when they expose their export also to the global
     * 			namespace, even when an AMD loader is present (as e.g. jQuery does) or when a shim is defined for them
     * 			using the `amd:true` flag (see example above)
     * 	 - Depending on configuration and the current context, `sap.ui.define` loads the dependencies of a module
     * 			either synchronously using a sync XHR call + eval or asynchronously via script tags. The sync loading
     * 			is basically a tribute to the synchronous history of UI5. There's no way for a module developer to enforce
     * 			synchronous loading of the dependencies and on the long run, sync loading will be faded out. Applications
     * 			that need to ensure synchronous loading of dependencies **MUST** use the deprecated legacy APIs like
     * 			{@link jQuery.sap.require}.
     * 	 - `sap.ui.define` does not support plugins to use other file types, formats or protocols. It is not
     * 			planned to support this in future
     * 	 - `sap.ui.define` does not support absolute URLs as module names (dependencies) nor does it allow module
     * 			names that start with a slash. To refer to a module at an absolute URL, a resource root can be registered
     * 			that points to that URL (or to a prefix of it).
     * 	 - `sap.ui.define` does **not** support the 'sugar' of requireJS where CommonJS style dependency declarations
     * 			using `sap.ui.require("something")` are automagically converted into `sap.ui.define` dependencies before
     * 			executing the factory function.
     *
     * Limitations, Design Considerations:
     * 	 - **Limitation**: as dependency management is not supported for Non-UI5 modules, the only way to ensure
     * 			proper execution order for such modules currently is to rely on the order in the dependency array. Obviously,
     * 			this only works as long as `sap.ui.define` uses synchronous loading. It will be enhanced when asynchronous
     * 			loading is implemented.
     * 	 - It was discussed to enforce asynchronous execution of the module factory function (e.g. with a timeout
     * 			of 0). But this would have invalidated the current migration scenario where a sync `jQuery.sap.require`
     * 			call can load a `sap.ui.define`'ed module. If the module definition would not execute synchronously,
     * 			the synchronous contract of the require call would be broken (default behavior in existing UI5 applications)
     *
     * 	 - A single file must not contain multiple calls to `sap.ui.define`. Multiple calls currently are only
     * 			supported in the so called 'preload' files that the UI5 merge tooling produces. The exact details of
     * 			how this works might be changed in future implementations and are not part of the API contract
     * See:
     * 	https://github.com/amdjs/amdjs-api
     */
    function define(
      /**
       * ID of the module in simplified resource name syntax. When omitted, the loader determines the ID from
       * the request.
       */
      sModuleName: string,
      /**
       * List of dependencies of the module
       */
      aDependencies: (
        | keyof sap.IUI5DefineDependencyNames
        | (string & { IGNORE_ME?: never }))[],
      /**
       * The module export value or a function that calculates that value
       */
      vFactory: Function | any,
      /**
       * Whether an export to global names is required - should be used by SAP-owned code only
       */
      bExport?: boolean
    ): void;
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.ExtensionPoint.load} instead
     *
     * Creates 0..n UI5 controls from an `ExtensionPoint`.
     *
     * One control if the `ExtensionPoint` is e.g. filled with a `View`, zero for extension points without configured
     * extension and n controls for multi-root `Fragments` as extension.
     *
     * In `JSViews`, this function allows both JSON notation in aggregation content as well as adding an extension
     * point to an aggregation after the target control has already been instantiated. In the latter case the
     * optional parameters oTargetControls and oTargetAggregation need to be specified.
     */
    function extensionpoint(
      /**
       * The view or fragment containing the extension point
       */
      oContainer: sap.ui.core.mvc.View | sap.ui.core.Fragment,
      /**
       * The extensionName used to identify the extension point in the customizing
       */
      sExtName: string,
      /**
       * Optional callback function creating default content, returning an array of controls. It is executed when
       * there's no customizing, if not provided, no default content will be rendered. `fnCreateDefaultContent`
       * might also return a Promise, which resolves with an array of controls.
       */
      fnCreateDefaultContent?: Function,
      /**
       * Optional - use this parameter to attach the extension point to a particular aggregation
       */
      oTargetControl?: sap.ui.core.Control,
      /**
       * Optional - if provided along with `oTargetControl`, the extension point content is added to this particular
       * aggregation at oTargetControl, if not given, but an oTargetControl is still present, the function will
       * attempt to add the extension point to the default aggregation of oTargetControl. If no oTargetControl
       * is provided, sAggregationName will also be ignored.
       */
      sAggregationName?: string
    ): sap.ui.core.Control[] | Promise<any>;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Instantiate a Fragment - this method loads the Fragment content, instantiates it, and returns this content.
     * The Fragment object itself is not an entity which has further significance beyond this constructor.
     *
     * To instantiate an existing Fragment, call this method as: sap.ui.fragment(sName, sType, [oController]);
     * The sName must correspond to an XML Fragment which can be loaded via the module system (fragmentName
     * + suffix ".fragment.[typeextension]") and which defines the Fragment content. If oController is given,
     * the (event handler) methods referenced in the Fragment will be called on this controller. Note that Fragments
     * may require a Controller to be given and certain methods to be available.
     *
     * The Fragment types "XML", "JS" and "HTML" are available by default; additional Fragment types can be
     * implemented and added using the sap.ui.core.Fragment.registerType() function.
     *
     * Advanced usage: To instantiate a Fragment and give further configuration options, call this method as:
     * sap.ui.fragment(oFragmentConfig, [oController]); The oFragmentConfig object can have the following properties:
     * - "fragmentName": the name of the Fragment, as above - "fragmentContent": the definition of the Fragment
     * content itself. When this property is given, any given name is ignored. The type of this property depends
     * on the Fragment type, e.g. it could be a string for XML Fragments. - "type": the type of the Fragment,
     * as above (mandatory) - "id": the ID of the Fragment (optional) Further properties may be supported by
     * future or custom Fragment types. Any given properties will be forwarded to the Fragment implementation.
     *
     * If you want to give a fixed ID for the Fragment, please use the advanced version of this method call
     * with the configuration object or use the typed factories like sap.ui.xmlfragment(...) or sap.ui.jsfragment(...).
     * Otherwise the Fragment ID is generated. In any case, the Fragment ID will be used as prefix for the ID
     * of all contained controls.
     */
    function fragment(
      /**
       * the Fragment name
       */
      sName: string,
      /**
       * the Fragment type, e.g. "XML", "JS", or "HTML"
       */
      sType: string,
      /**
       * the Controller which should be used by the controls in the Fragment. Note that some Fragments may not
       * need a Controller and other may need one - and even rely on certain methods implemented in the Controller.
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * Retrieve the {@link sap.ui.core.Core SAPUI5 Core} instance for the current window.
     */
    function getCore(): sap.ui.core.Core;
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.VersionInfo.load} instead
     *
     * Loads the version info file (resources/sap-ui-version.json) and returns it or if a library name is specified
     * then the version info of the individual library will be returned.
     *
     * In case of the version info file is not available an error will occur when calling this function.
     */
    function getVersionInfo(
      /**
       * name of the library (e.g. "sap.ui.core") or an object map (see below)
       */
      mOptions?: {
        /**
         * name of the library (e.g. "sap.ui.core")
         */
        library?: boolean;
        /**
         * whether "sap-ui-version.json" should be loaded asynchronously
         */
        async?: boolean;
        /**
         * whether to propagate load errors or not (not relevant for async loading)
         */
        failOnError?: boolean;
      }
    ): object | undefined | Promise<any>;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Instantiates an HTML-based Fragment.
     *
     * To instantiate a Fragment, call this method as: sap.ui.htmlfragment([sId], sFragmentName, [oController]);
     * The Fragment instance ID is optional and will be used as prefix for the ID of all contained controls.
     * If no ID is passed, controls will not be prefixed. The sFragmentName must correspond to an HTML Fragment
     * which can be loaded via the module system (fragmentName + ".fragment.html") and which defines the Fragment.
     * If oController is given, the methods referenced in the Fragment will be called on this controller. Note
     * that Fragments may require a Controller to be given and certain methods to be available.
     *
     * Advanced usage: To instantiate a Fragment and optionally directly give the HTML definition instead of
     * loading it from a file, call this method as: sap.ui.htmlfragment(oFragmentConfig, [oController]); The
     * oFragmentConfig object can either have a "fragmentName" or a "fragmentContent" property. fragmentContent
     * is optional and can hold the Fragment definition as XML string; if not given, fragmentName must be given
     * and the Fragment content definition is loaded by the module system. Again, if oController is given, the
     * methods referenced in the Fragment will be called on this controller.
     */
    function htmlfragment(
      /**
       * id of the newly created Fragment
       */
      sId: string,
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired.)
       */
      vFragment: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.HTMLView.create HTMLView.create} instead
     *
     * Defines or creates an instance of a declarative HTML view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     *
     * 	 - View Definition `sap.ui.htmlview(sId, vView)`: Defines a view of the given name with the given implementation.
     * 			sId must be the views name, vView must be an object and can contain implementations for any of the hooks
     * 			provided by HTMLView
     * 	 - View Instantiation `sap.ui.htmlview(sId?, vView)`: Creates an instance of the view with the given
     * 			name (and id).
     *
     * Any other call signature will lead to a runtime error. If the id is omitted in the second variant, an
     * id will be created automatically.
     */
    function htmlview(
      /**
       * id of the newly created view, only allowed for instance creation
       */
      sId: string,
      /**
       * name or implementation of the view.
       */
      vView: {
        /**
         * defines how the view source is loaded and rendered later on
         */
        async?: boolean;
      }
    ): sap.ui.core.mvc.HTMLView | undefined;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Defines OR instantiates an HTML-based Fragment.
     *
     * To define a JS Fragment, call this method as: sap.ui.jsfragment(sName, oFragmentDefinition) Where: -
     * "sName" is the name by which this fragment can be found and instantiated. If defined in its own file,
     * in order to be found by the module loading system, the file location and name must correspond to sName
     * (path + file name must be: fragmentName + ".fragment.js"). - "oFragmentDefinition" is an object at least
     * holding the "createContent(oController)" method which defines the Fragment content. If given during instantiation,
     * the createContent method receives a Controller instance (otherwise oController is undefined) and the
     * return value must be one sap.ui.core.Control (which could have any number of children).
     *
     * To instantiate a JS Fragment, call this method as: sap.ui.jsfragment([sId], sFragmentName, [oController]);
     * The Fragment ID is optional (generated if not given) and the Fragment implementation CAN use it to make
     * contained controls unique (this depends on the implementation: some JS Fragments may choose not to support
     * multiple instances within one application and not use the ID prefixing). The sFragmentName must correspond
     * to a JS Fragment which can be loaded via the module system (fragmentName + ".fragment.js") and which
     * defines the Fragment. If oController is given, the methods referenced in the Fragment will be called
     * on this controller. Note that Fragments may require a Controller to be given and certain methods to be
     * available.
     */
    function jsfragment(
      /**
       * id of the newly created Fragment
       */
      sId: string,
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired)
       */
      sFragmentName: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.JSONView.create JSONView.create} instead.
     *
     * Creates a JSON view of the given name and id.
     *
     * The `viewName` must either correspond to a JSON module that can be loaded via the module system (viewName
     * + suffix ".view.json") and which defines the view or it must be a configuration object for a view. The
     * configuration object can have a viewName, viewContent and a controller property. The viewName behaves
     * as described above, viewContent can hold the view description as JSON string or as object literal.
     *
     * **Note**: when an object literal is given, it might be modified during view construction.
     *
     * The controller property can hold a controller instance. If a controller instance is given, it overrides
     * the controller defined in the view.
     *
     * When property `async` is set to true, the view definition and the controller class (and its dependencies)
     * will be loaded asynchronously. Any controls used in the view might be loaded sync or async, depending
     * on the experimental runtime configuration option "xx-xml-processing". Even when the view definition is
     * provided as string or object tree, controller or controls might be loaded asynchronously. In any case,
     * a view instance will be returned synchronously by this factory API, but its content (control tree) might
     * appear only later. Also see {@link sap.ui.core.mvc.View#loaded}.
     *
     * Like with any other control, an id is optional and will be created when missing.
     */
    function jsonview(
      /**
       * id of the newly created view
       */
      sId: string,
      /**
       * name of a view resource or view configuration as described above.
       */
      vView: {
        /**
         * name of a view resource in module name notation (without suffix)
         */
        viewName?: string;
        /**
         * view definition as a JSON string or an object literal
         */
        viewContent?: string | object;
        /**
         * defines how the view source is loaded and rendered later on
         */
        async?: boolean;
        /**
         * controller to be used for this view instance
         */
        controller?: sap.ui.core.mvc.Controller;
      }
    ): sap.ui.core.mvc.JSONView;
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.JSView.create JSView.create} to create view instances;
     * for defining JavaScript views, there's no substitute yet and ***sap.ui.jsview*** still has to be used
     *
     * Defines or creates an instance of a JavaScript view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     * View Definition:
     * ```javascript
     *
     *   sap.ui.jsview(sId, vView);
     * ```
     *  Defines a view of the given name with the given implementation. `sId` must be the view's name, `vView`
     * must be an object and can contain implementations for any of the hooks provided by JSView.
     *
     * View Instantiation (deprecated):
     * ```javascript
     *
     *   var oView = sap.ui.jsview(vView);
     *   var oView = sap.ui.jsview(vView, bASync);
     *   var oView = sap.ui.jsview(sId, vView);
     *   var oView = sap.ui.jsview(sId, vView, bAsync);
     * ```
     *  Creates an instance of the view with the given name (and id). If no view implementation has been defined
     * for that view name, a JavaScript module with the same qualified name and with suffix `.view.js` will
     * be loaded (required) and executed. The module should register a view definition on execution (1st. variant
     * above).
     *
     * If `sId` is omitted, an ID will be created automatically.
     *
     * When `bAsync` has a truthy value, the view definition will be read asynchronously, if needed, but the
     * (incomplete) view instance will be returned immediately.
     *
     * **Note:** Using `sap.ui.jsview` for creating view instances has been deprecated, use {@link sap.ui.core.mvc.JSView.create
     * JSView.create} instead. `JSView.create` enforces asynchronous loading and can be used via an AMD reference,
     * it doesn't rely on a global name.
     *
     * **Note:** Any other call signature will lead to a runtime error.
     */
    function jsview(
      /**
       * id of the newly created view, only allowed for instance creation
       */
      sId: string,
      /**
       * name or implementation of the view.
       */
      vView: string | object,
      /**
       * defines how the view source is loaded and rendered later on (only relevant for instantiation, ignored
       * for everything else)
       */
      bAsync?: boolean
    ): sap.ui.core.mvc.JSView | undefined;
    /**
     * @deprecated (since 1.56)
     *
     * Creates a lazy loading stub for a given class `sClassName`.
     *
     * If the class has been loaded already, nothing is done. Otherwise a stub object or constructor and - optionally
     * - a set of stub methods are created. All created stubs will load the corresponding module on execution
     * and then delegate to their counterpart in the loaded module.
     *
     * When no methods are given or when the list of methods contains the special name "new" (which is an operator
     * can't be used as method name in JavaScript), then a stub **constructor** for class `sClassName` is created.
     * Otherwise, a plain object is created.
     *
     * **Note**: Accessing any stub as a plain object without executing it (no matter whether it is a function
     * or an object) won't load the module and therefore most like won't work as expected. This is a fundamental
     * restriction of the lazy loader approach. It could only be fixed with JavaScript 1.5 features that are
     * not available in all UI5 target browsers (e.g. not in IE8).
     *
     * **Note**: As a side effect of this method, the namespace containing the given class is created **immediately**.
     */
    function lazyRequire(
      /**
       * Fully qualified name (dot notation) of the class that should be prepared
       */
      sClassName: string,
      /**
       * space separated list of additional (static) methods that should be created as stubs
       */
      sMethods?: string,
      /**
       * name of the module to load, defaults to the class name
       */
      sModuleName?: string
    ): void;
    /**
     * @deprecated (since 1.56) - use `sap.ui.loader.config` instead.
     *
     * Redirects access to resources that are part of the given namespace to a location relative to the assumed
     * **application root folder**.
     *
     * Any UI5 managed resource (view, controller, control, JavaScript module, CSS file, etc.) whose resource
     * name starts with `sNamespace`, will be loaded from an equally named subfolder of the **application root
     * folder**. If the resource name consists of multiple segments (separated by a dot), each segment is assumed
     * to represent an individual folder. In other words: when a resource name is converted to a URL, any dots
     * ('.') are converted to slashes ('/').
     *
     * **Limitation:** For the time being, the **application root folder** is assumed to be the same as the
     * folder where the current page resides in.
     *
     * Usage sample:
     * ```javascript
     *
     *   // Let UI5 know that resources, whose name starts with "com.mycompany.myapp"
     *   // should be loaded from the URL location "./com/mycompany/myapp"
     *   sap.ui.localResources("com.mycompany.myapp");
     *
     *   // The following call implicitly will use the mapping done by the previous line
     *   // It will load a view from ./com/mycompany/myapp/views/Main.view.xml
     *   View.create({ viewName : "com.mycompany.myapp.views.Main", type : ViewType.XML}).then(function(oView) {
     *       // do stuff
     *   });
     * ```
     *
     *
     * When applications need a more flexible mapping between resource names and their location, they can use
     * {@link jQuery.sap.registerModulePath}.
     *
     * It is intended to make this configuration obsolete in future releases, but for the time being, applications
     * must call this method when they want to store resources relative to the assumed application root folder.
     * See:
     * 	jQuery.sap.registerModulePath
     */
    function localResources(
      /**
       * Namespace prefix for which to load resources relative to the application root folder
       */
      sNamespace: string
    ): void;
    /**
     * @deprecated (since 1.1) - see {@link topic:c78c07c094e04ccfaab659378a1707c7 Creating Control and Class
     * Modules}.
     *
     * Ensures that a given a namespace or hierarchy of nested namespaces exists in the current `window`.
     */
    function namespace(sNamespace: string): object;
    /**
     * Resolves one or more module dependencies.
     *
     * Synchronous Retrieval of a Single Module Export Value (Probing):
     *
     * When called with a single string, that string is assumed to be the ID of an already loaded module and
     * the export of that module is returned. If the module has not been loaded yet, or if it is a Non-UI5 module
     * (e.g. third-party module) without a shim, `undefined` is returned.
     *
     * This signature variant allows synchronous access to module exports without initiating module loading.
     *
     * Sample:
     * ```javascript
     *
     *   var JSONModel = sap.ui.require("sap/ui/model/json/JSONModel");
     * ```
     *
     *
     * For modules that are known to be UI5 modules, this signature variant can be used to check whether the
     * module has been loaded.
     *
     * Asynchronous Loading of Multiple Modules:
     *
     * If an array of strings is given and (optionally) a callback function, then the strings are interpreted
     * as module IDs and the corresponding modules (and their transitive dependencies) are loaded. Then the
     * callback function will be called asynchronously. The module exports of the specified modules will be
     * provided as parameters to the callback function in the same order in which they appeared in the dependencies
     * array.
     *
     * The return value for the asynchronous use case is `undefined`.
     *
     *
     * ```javascript
     *
     *   sap.ui.require(['sap/ui/model/json/JSONModel', 'sap/ui/core/UIComponent'], function(JSONModel,UIComponent) {
     *
     *     var MyComponent = UIComponent.extend('MyComponent', {
     *       ...
     *     });
     *     ...
     *
     *   });
     * ```
     *
     *
     * This method uses the same variation of the {@link jQuery.sap.getResourcePath unified resource name} syntax
     * that {@link sap.ui.define} uses: module names are specified without the implicit extension '.js'. Relative
     * module names are not supported.
     */
    function require(
      /**
       * Dependency (dependencies) to resolve
       */
      vDependencies: string | string[],
      /**
       * Callback function to execute after resolving an array of dependencies
       */
      fnCallback?: Function,
      /**
       * Callback function to execute if an error was detected while loading the dependencies or executing the
       * factory function. Note that due to browser limitations not all errors will be reported via this callback.
       * In general, module loading is designed for the non-error case. Error handling is not complete.
       */
      fnErrback?: Function
    ): any | undefined;
    /**
     * @deprecated (since 1.56.0) - use `sap.ui.require.toUrl` instead.
     *
     * Returns the URL of a resource that belongs to the given library and has the given relative location within
     * the library. This is mainly meant for static resources like images that are inside the library. It is
     * NOT meant for access to JavaScript modules or anything for which a different URL has been registered
     * with jQuery.sap.registerModulePath(). For these cases use jQuery.sap.getModulePath(). It DOES work, however,
     * when the given sResourcePath starts with "themes/" (= when it is a theme-dependent resource). Even when
     * for this theme a different location outside the normal library location is configured.
     */
    function resource(
      /**
       * the name of a library, like "sap.ui.commons"
       */
      sLibraryName: string,
      /**
       * the relative path of a resource inside this library, like "img/mypic.png" or "themes/my_theme/img/mypic.png"
       */
      sResourcePath: string
    ): string;
    /**
     * @deprecated (since 1.1) - use {@link sap.ui.core.Control#placeAt Control#placeAt} instead.
     *
     * Displays the control tree with the given root inside the area of the given DOM reference (or inside the
     * DOM node with the given ID) or in the given Control.
     *
     * Example:
     * ```javascript
     *
     *   <div id="SAPUI5UiArea"></div>
     *   <script>
     *     var oRoot = new sap.ui.commons.Label();
     *     oRoot.setText("Hello world!");
     *     sap.ui.setRoot("SAPUI5UiArea", oRoot);
     *   </script>
     * ```
     *
     *
     * This is a shortcut for `sap.ui.getCore().setRoot()`.
     *
     * Internally, if a string is given that does not identify a UIArea or a control then implicitly a new `UIArea`
     * is created for the given DOM reference and the given control is added.
     */
    function setRoot(
      /**
       * a DOM Element or Id String of the UIArea
       */
      oDomRef: string | Element | sap.ui.core.Control,
      /**
       * the Control that should be added to the `UIArea`.
       */
      oControl: sap.ui.base.Interface | sap.ui.core.Control
    ): void;
    /**
     * @deprecated (since 1.56) - use an {@link sap.ui.core.mvc.XMLView XMLView} or {@link sap.ui.core.mvc.JSView
     * JSView} instead.
     *
     * Creates a Template for the given ID, DOM reference or a configuration object.
     *
     * If no parameter is defined, this function makes a lookup of DOM elements which are specifying a type
     * attribute. If the value of this type attribute matches a registered type then the content of this DOM
     * element will be used to create a new `Template` instance.
     *
     * If you want to lookup all kind of existing and known templates and parse them directly you can simply
     * call:
     * ```javascript
     *
     *   sap.ui.template();
     * ```
     *
     *
     * To parse a concrete DOM element you can do so by using this function in the following way:
     * ```javascript
     *
     *   sap.ui.template("theTemplateId");
     * ```
     *
     *
     * Or you can pass the reference to a DOM element and use this DOM element as a source for the template:
     *
     * ```javascript
     *
     *   sap.ui.template(oDomRef);
     * ```
     *
     *
     * The last option to use this function is to pass the information via a configuration object. This configuration
     * object can be used to pass a context for the templating framework when compiling the template:
     * ```javascript
     *
     *   var oTemplateById = sap.ui.template({
     *     id: "theTemplateId",
     *     context: { ... }
     *   });
     *
     *   var oTemplateByDomRef = sap.ui.template({
     *     domref: oDomRef,
     *     context: { ... }
     *   });
     * ```
     *
     *
     * It can also be used to load a template from another file:
     * ```javascript
     *
     *   var oTemplate = sap.ui.template({
     *     id: "myTemplate",
     *     src: "myTemplate.tmpl"
     *   });
     *
     *   var oTemplateWithContext = sap.ui.template({
     *     id: "myTemplate",
     *     src: "myTemplate.tmpl",
     *     context: { ... }
     *   });
     * ```
     */
    function template(
      /**
       * the ID or the DOM reference to the template to lookup or a configuration object containing the src, type
       * and eventually the ID of the Template.
       */
      oTemplate?: {
        /**
         * the ID of the Template / the ID of the DOM element containing the source of the Template
         */
        id: string;
        /**
         * the DOM element containing the source of the Template
         */
        domref: Element;
        /**
         * the type of the Template
         */
        type?: string;
        /**
         * the context for the renderer/templating
         */
        context?: object;
        /**
         * the URL to lookup the template (experimental!)
         */
        src?: string;
        /**
         * the fully qualified name of the control to declare (experimental!)
         */
        control: string;
      }
    ): sap.ui.core.tmpl.Template | sap.ui.core.tmpl.Template[];
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.XMLView} in combination with {@link topic:5ee619fc1370463ea674ee04b65ed83b
     * XML Templating} instead
     *
     * Defines or creates an instance of a template view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     *
     * 	 - View Definition `sap.ui.templateview(sId, vView)`: Defines a view of the given name with the given
     * 			implementation. sId must be the views name, vView must be an object and can contain implementations for
     * 			any of the hooks provided by templateview
     * 	 - View Instantiation `sap.ui.templateview(sId?, vView)`: Creates an instance of the view with the given
     * 			name (and id).
     *
     * Any other call signature will lead to a runtime error. If the id is omitted in the second variant, an
     * id will be created automatically.
     */
    function templateview(
      /**
       * id of the newly created view, only allowed for instance creation
       */
      sId: string,
      /**
       * name or implementation of the view.
       */
      vView: string | object
    ): sap.ui.core.mvc.TemplateView | undefined;
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.View.create View.create} instead
     *
     * Creates a view of the given type, name and with the given id.
     *
     * The `vView` configuration object can have the following properties for the view instantiation:
     * 	 - The ID `vView.id` specifies an ID for the View instance. If no ID is given, an ID will be generated.
     *
     * 	 - The view name `vView.viewName` corresponds to an XML module that can be loaded via the module system
     * 			(vView.viewName + suffix ".view.xml")
     * 	 - The controller instance `vView.controller` must be a valid controller implementation. The given controller
     * 			instance overrides the controller defined in the view definition
     * 	 - The view type `vView.type` specifies what kind of view will be instantiated. All valid view types
     * 			are listed in the enumeration sap.ui.core.mvc.ViewType.
     * 	 - The view data `vView.viewData` can hold user specific data. This data is available during the whole
     * 			lifecycle of the view and the controller
     * 	 - The view loading mode `vView.async` must be a boolean and defines if the view source is loaded synchronously
     * 			or asynchronously. In async mode, the view is rendered empty initially, and re-rendered with the loaded
     * 			view content.
     * 	 - `vView.preprocessors` can hold a map from the specified preprocessor type (e.g. "xml") to an array
     * 			of preprocessor configurations; each configuration consists of a `preprocessor` property (optional when
     * 			registered as on-demand preprocessor) and may contain further preprocessor-specific settings. The preprocessor
     * 			can be either a module name as string implementation of {@link sap.ui.core.mvc.View.Preprocessor} or
     * 			a function according to {@link sap.ui.core.mvc.View.Preprocessor.process}. Do not set properties starting
     * 			with underscore like `_sProperty` property, these are reserved for internal purposes. When several preprocessors
     * 			are provided for one hook, it has to be made sure that they do not conflict when being processed serially.
     *
     * **Note**: These preprocessors are only available to this instance. For global or on-demand availability
     * use {@link sap.ui.core.mvc.XMLView.registerPreprocessor}.
     *
     * **Note**: Please note that preprocessors in general are currently only available to XMLViews.
     *
     * **Note**: Preprocessors only work in async views and will be ignored when the view is instantiated in
     * sync mode by default, as this could have unexpected side effects. You may override this behaviour by
     * setting the bSyncSupport flag of the preprocessor to true.
     */
    function view(
      /**
       * id of the newly created view, only allowed for instance creation
       */
      sId: string,
      /**
       * the view name or view configuration object
       */
      vView: {
        /**
         * defines how the view source is loaded and rendered later on
         */
        async?: boolean;
      },
      /**
       * Specifies what kind of view will be instantiated. All valid view types are listed in the enumeration
       * {@link sap.ui.core.mvc.ViewType}.
       */
      sType: any
    ): sap.ui.core.mvc.View;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Instantiates an XML-based Fragment.
     *
     * To instantiate a Fragment, call this method as: sap.ui.xmlfragment([sId], sFragmentName, [oController]);
     * The Fragment instance ID is optional and will be used as prefix for the ID of all contained controls.
     * If no ID is passed, controls will not be prefixed. The sFragmentName must correspond to an XML Fragment
     * which can be loaded via the module system (fragmentName + ".fragment.xml") and which defines the Fragment.
     * If oController is given, the methods referenced in the Fragment will be called on this controller. Note
     * that Fragments may require a Controller to be given and certain methods to be available.
     *
     * Advanced usage: To instantiate a Fragment and optionally directly give the XML definition instead of
     * loading it from a file, call this method as: sap.ui.xmlfragment(oFragmentConfig, [oController]); The
     * oFragmentConfig object can either have a "fragmentName" or a "fragmentContent" property. fragmentContent
     * is optional and can hold the Fragment definition as XML string; if not given, fragmentName must be given
     * and the Fragment content definition is loaded by the module system. Again, if oController is given, the
     * methods referenced in the Fragment will be called on this controller.
     */
    function xmlfragment(
      /**
       * id of the newly created Fragment
       */
      sId: string,
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired)
       */
      vFragment: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.XMLView.create XMLView.create} instead
     *
     * Instantiates an XMLView of the given name and with the given ID.
     *
     * The `vView` can either be the name of the module that contains the view definition or it can be a configuration
     * object with properties `viewName`, `viewContent` and a `controller` property (more properties are described
     * in the parameters section below).
     *
     * If a `viewName` is given, it behaves the same as when `vView` is a string: the named resource will be
     * loaded and parsed as XML. Alternatively, an already loaded view definition can be provided as `viewContent`,
     * either as XML string or as an already parsed XML document. Exactly one of `viewName` and `viewContent`
     * must be given, if none or both are given, an error will be reported. The `controller` property is optional
     * and can hold a controller instance. When given, it overrides the controller class defined in the view
     * definition.
     *
     * When property `async` is set to true, the view definition and the controller class (and its dependencies)
     * will be loaded asynchronously. Any controls used in the view might be loaded sync or async, this depends
     * on the experimental runtime configuration option "xx-xml-processing". Even when the view definition is
     * provided as string or XML Document, controller or controls might be loaded asynchronously. In any case
     * a view instance will be returned synchronously by this factory API, but its content (control tree) might
     * appear only later. Also see {@link sap.ui.core.mvc.View#loaded}.
     *
     * **Note**: If an XML document is given, it might be modified during view construction.
     *
     * **Note**: On root level, you can only define content for the default aggregation, e.g. without adding
     * the `<content>` tag. If you want to specify content for another aggregation of a view like `dependents`,
     * place it in a child control's dependents aggregation or add it by using {@link sap.ui.core.mvc.XMLView#addDependent}.
     *
     * **Note**: If you enable caching, you need to take care of the invalidation via keys. Automatic invalidation
     * takes only place if the UI5 version or the component descriptor (manifest.json) change. This is still
     * an experimental feature and may experience slight changes of the invalidation parameters or the cache
     * key format.
     *
     * Like with any other control, `sId` is optional and an ID will be created automatically.
     */
    function xmlview(
      /**
       * ID of the newly created view
       */
      sId: string,
      /**
       * Name of the view or a view configuration object as described above
       */
      vView: {
        /**
         * Name of the view resource in module name notation (without suffix)
         */
        viewName?: string;
        /**
         * XML string or XML document that defines the view
         */
        viewContent?: string | Document;
        /**
         * Defines how the view source is loaded and rendered later on
         */
        async?: boolean;
        /**
         * Cache configuration, only for `async` views; caching gets active when this object is provided with vView.cache.keys
         * array; keys are used to store data in the cache and for invalidation of the cache
         */
        cache?: {
          /**
           * Array with strings or Promises resolving with strings
           */
          keys?: any;
        };

        /**
         * Preprocessors configuration, see {@link sap.ui.core.mvc.View}
         */
        preprocessors?: object;
        /**
         * Controller instance to be used for this view
         */
        controller?: sap.ui.core.mvc.Controller;
      }
    ): sap.ui.core.mvc.XMLView;
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.Controller.create Controller.create} or {@link
     * sap.ui.core.mvc.Controller.extend Controller.extend} instead.
     *
     * Defines a controller class or creates an instance of an already defined controller class.
     *
     * When a name and a controller implementation object is given, a new controller class of the given name
     * is created. The members of the implementation object will be copied into each new instance of that controller
     * class (shallow copy). **Note**: as the members are shallow copied, controller instances will share all
     * object values. This might or might not be what applications expect.
     *
     * If only a name is given, a new instance of the named controller class is returned.
     */
    function controller(
      /**
       * The controller name
       */
      sName: string,
      /**
       * Decides whether the controller gets loaded asynchronously or not
       */
      bAsync: boolean
    ): void | sap.ui.core.mvc.Controller | Promise<any>;
    /**
     * @SINCE 1.27.0
     *
     * Defines a JavaScript module with its ID, its dependencies and a module export value or factory.
     *
     * The typical and only suggested usage of this method is to have one single, top level call to `sap.ui.define`
     * in one JavaScript resource (file). When a module is requested by its module ID for the first time, the
     * corresponding resource is determined from the ID and the current {@link sap.ui.loader.config configuration}.
     * The resource will be loaded and executed which in turn will execute the top level `sap.ui.define` call.
     *
     * If the module ID was omitted from that call, it will be substituted by the ID that was used to request
     * the module. As a preparation step, the dependencies as well as their transitive dependencies, will be
     * loaded. Then, the module value (its export) will be determined: if a static value (object, literal) was
     * given as `vFactory`, that value will be the module value. If a function was given, that function will
     * be called (providing the module exports of the declared dependencies as parameters to the function) and
     * its return value will be used as module export value. The framework internally associates the resulting
     * value with the module ID and provides it to the original requester of the module. Whenever the module
     * is requested again, the same export value will be returned (modules are executed only once).
     *
     * Example:
     *  The following example defines a module, but doesn't hard code the module ID. If stored in a file 'sap/mylib/SomeClass.js',
     * it can be requested with the ID 'sap/mylib/SomeClass'.
     * ```javascript
     *
     *   sap.ui.define(['./Helper', 'sap/m/Bar'], function(Helper,Bar) {
     *
     *     // create a new class
     *     var SomeClass = function() {};
     *
     *     // add methods to its prototype
     *     SomeClass.prototype.foo = function() {
     *
     *         // use a function from the dependency 'Helper' in the same package (e.g. 'sap/mylib/Helper' )
     *         var mSettings = Helper.foo();
     *
     *         // create and return an sap.m.Bar (using its local name 'Bar')
     *         return new Bar(mSettings);
     *
     *     }
     *
     *     // return the class as module value
     *     return SomeClass;
     *
     *   });
     * ```
     *
     *
     * In another module or in an application HTML page, the {@link sap.ui.require} API can be used to load
     * the sap/mylib/Something module and to work with it:
     *
     *
     * ```javascript
     *
     * sap.ui.require(['sap/mylib/Something'], function(Something) {
     *
     *   // instantiate a Something and call foo() on it
     *   new Something().foo();
     *
     * });
     * ```
     *
     *
     * Module Name Syntax:
     *
     * `sap.ui.define` uses a simplified variant of the {@link jQuery.sap.getResourcePath unified resource name}
     * syntax for the module's own name as well as for its dependencies. The only difference to that syntax
     * is, that for `sap.ui.define` and `sap.ui.require`, the extension (which always would be '.js') has to
     * be omitted. Both methods always add this extension internally.
     *
     * As a convenience, the name of a dependency can start with the segment './' which will be replaced by
     * the name of the package that contains the currently defined module (relative name).
     *
     * It is best practice to omit the name of the defined module (first parameter) and to use relative names
     * for the dependencies whenever possible. This reduces the necessary configuration, simplifies renaming
     * of packages and allows to map them to a different namespace.
     *
     * Dependency to Modules:
     *
     * If a dependencies array is given, each entry represents the name of another module that the currently
     * defined module depends on. All dependency modules are loaded before the export of the currently defined
     * module is determined. The module export of each dependency module will be provided as a parameter to
     * a factory function, the order of the parameters will match the order of the modules in the dependencies
     * array.
     *
     * **Note:** The order in which the dependency modules are executed is **not** defined by the order
     * in the dependencies array! The execution order is affected by dependencies between the dependency
     * modules as well as by their current state (whether a module already has been loaded or not). Neither
     * module implementations nor dependents that require a module set must make any assumption about the execution
     * order (other than expressed by their dependencies).
     *
     * **Note:** A static module export (a literal provided to `sap.ui.define`) cannot depend on the module
     * exports of the dependency modules as it has to be calculated before the dependencies are resolved. As
     * an alternative, modules can define a factory function, calculate a static export value in that function,
     * potentially based on the dependencies, and return the result as module export value. The same approach
     * must be taken when the module export is supposed to be a function.
     *
     * Asynchronous Contract:
     *
     * `sap.ui.define` is designed to support real Asynchronous Module Definitions (AMD) in future, although
     * it internally still might use synchronous module loading, depending on configuration and context. However,
     * callers of `sap.ui.define` must never rely on any synchronous behavior that they might observe in a specific
     * test scenario.
     *
     * For example, callers of `sap.ui.define` must not use the module export value immediately after invoking
     * `sap.ui.define`:
     *
     *
     * ```javascript
     *
     *   // COUNTER EXAMPLE HOW __NOT__ TO DO IT
     *
     *   // define a class Something as AMD module
     *   sap.ui.define('Something', [], function() {
     *     var Something = function() {};
     *     return Something;
     *   });
     *
     *   // DON'T DO THAT!
     *   // accessing the class _synchronously_ after sap.ui.define was called
     *   new Something();
     *
     * ```
     *
     *
     * Applications that need to ensure synchronous module definition or synchronous loading of dependencies
     * **MUST** use the deprecated legacy APIs {@link jQuery.sap.declare} and {@link jQuery.sap.require}.
     *
     * (No) Global References:
     *
     * To be in line with AMD best practices, modules defined with `sap.ui.define` should not make any use of
     * global variables if those variables are also available as module exports. Instead, they should add dependencies
     * to those modules and use the corresponding parameter of the factory function to access the module exports.
     *
     * As the current programming model and the documentation of UI5 heavily rely on global names, there will
     * be a transition phase where UI5 enables AMD modules and local references to module exports in parallel
     * to the old global names. The fourth parameter of `sap.ui.define` has been added to support that transition
     * phase. When this parameter is set to true, the framework provides two additional features
     *
     *
     * 	 - Before the factory function is called, the existence of the global parent namespace for the current
     * 			module is ensured
     * 	 - The module export returned by the module's factory function will be automatically exported under
     * 			the global name which is derived from the ID of the module
     *
     * The parameter lets the framework know whether any of those two operations is needed or not. In future
     * versions of UI5, a central configuration option is planned to suppress those 'exports'.
     *
     * Third Party Modules: Although third party modules don't use UI5 APIs, they still can be listed as dependencies
     * in a `sap.ui.define` call. They will be requested and executed like UI5 modules, but to make their exports
     * available, so called ***shims*** have to be defined.
     *
     * Note that UI5 temporarily deactivates an existing AMD loader while it executes third party modules known
     * to support AMD. This sounds contradictorily at a first glance as UI5 wants to support AMD, but for now
     * it is necessary to fully support UI5 applications that rely on global names for such modules.
     *
     * For third-party modules that UI5 delivers (e.g. those in namespace `sap/ui/thirdparty/`), the necessary
     * shims are defined by UI5 itself by executing the private module `ui5loader-autoconfig.js` during bootstrap.
     *
     * Example:
     * ```javascript
     *
     *   // module 'Something' wants to use third party library 'URI.js'
     *   // It is packaged by UI5 as non-UI5-module 'sap/ui/thirdparty/URI'
     *   // the following shim helps UI5 to correctly load URI.js and to retrieve the module's export value
     *   // Apps don't have to define that shim, it is already applied by ui5loader-autconfig.js
     *   sap.ui.loader.config({
     *     shim: {
     *       'sap/ui/thirdparty/URI': {
     *          amd: true, // URI.js reacts on an AMD loader, this flag lets UI5 temp. disable such loaders
     *          exports: 'URI' // name of the global variable under which URI.js exports its module value
     *       }
     *     }
     *   });
     *
     *   // now the module can be retrieved like other modules
     *   sap.ui.define('Something', ['sap/ui/thirdparty/URI'], function(URIModuleValue) {
     *
     *     new URIModuleValue(...); // same as the global 'URI' name: new URI(...)
     *
     *     ...
     *   });
     * ```
     *
     *
     * Differences to Standard AMD:
     *
     * The current implementation of `sap.ui.define` differs from the AMD specification (https://github.com/amdjs/amdjs-api)
     * or from concrete AMD loaders like `requireJS` in several aspects:
     * 	 - The name `sap.ui.define` is different from the plain `define`. This has two reasons: first, it avoids
     * 			the impression that `sap.ui.define` is an exact implementation of an AMD loader. And second, it allows
     * 			the coexistence of an AMD loader (e.g. requireJS) and `sap.ui.define` in one application as long as UI5
     * 			or applications using UI5 are not fully prepared to run with an AMD loader. Note that the difference
     * 			of the API names also implies that the UI5 loader can't be used to load 'real' AMD modules as they expect
     * 			methods `define` and `require` to be available. Modules that use Unified Module Definition (UMD) syntax,
     * 			can be loaded, but only when no AMD loader is present or when they expose their export also to the global
     * 			namespace, even when an AMD loader is present (as e.g. jQuery does) or when a shim is defined for them
     * 			using the `amd:true` flag (see example above)
     * 	 - Depending on configuration and the current context, `sap.ui.define` loads the dependencies of a module
     * 			either synchronously using a sync XHR call + eval or asynchronously via script tags. The sync loading
     * 			is basically a tribute to the synchronous history of UI5. There's no way for a module developer to enforce
     * 			synchronous loading of the dependencies and on the long run, sync loading will be faded out. Applications
     * 			that need to ensure synchronous loading of dependencies **MUST** use the deprecated legacy APIs like
     * 			{@link jQuery.sap.require}.
     * 	 - `sap.ui.define` does not support plugins to use other file types, formats or protocols. It is not
     * 			planned to support this in future
     * 	 - `sap.ui.define` does not support absolute URLs as module names (dependencies) nor does it allow module
     * 			names that start with a slash. To refer to a module at an absolute URL, a resource root can be registered
     * 			that points to that URL (or to a prefix of it).
     * 	 - `sap.ui.define` does **not** support the 'sugar' of requireJS where CommonJS style dependency declarations
     * 			using `sap.ui.require("something")` are automagically converted into `sap.ui.define` dependencies before
     * 			executing the factory function.
     *
     * Limitations, Design Considerations:
     * 	 - **Limitation**: as dependency management is not supported for Non-UI5 modules, the only way to ensure
     * 			proper execution order for such modules currently is to rely on the order in the dependency array. Obviously,
     * 			this only works as long as `sap.ui.define` uses synchronous loading. It will be enhanced when asynchronous
     * 			loading is implemented.
     * 	 - It was discussed to enforce asynchronous execution of the module factory function (e.g. with a timeout
     * 			of 0). But this would have invalidated the current migration scenario where a sync `jQuery.sap.require`
     * 			call can load a `sap.ui.define`'ed module. If the module definition would not execute synchronously,
     * 			the synchronous contract of the require call would be broken (default behavior in existing UI5 applications)
     *
     * 	 - A single file must not contain multiple calls to `sap.ui.define`. Multiple calls currently are only
     * 			supported in the so called 'preload' files that the UI5 merge tooling produces. The exact details of
     * 			how this works might be changed in future implementations and are not part of the API contract
     * See:
     * 	https://github.com/amdjs/amdjs-api
     */
    function define(
      /**
       * ID of the module in simplified resource name syntax. When omitted, the loader determines the ID from
       * the request.
       */
      sModuleName: string,
      /**
       * The module export value or a function that calculates that value
       */
      vFactory: Function | any,
      /**
       * Whether an export to global names is required - should be used by SAP-owned code only
       */
      bExport?: boolean
    ): void;
    /**
     * @SINCE 1.27.0
     *
     * Defines a JavaScript module with its ID, its dependencies and a module export value or factory.
     *
     * The typical and only suggested usage of this method is to have one single, top level call to `sap.ui.define`
     * in one JavaScript resource (file). When a module is requested by its module ID for the first time, the
     * corresponding resource is determined from the ID and the current {@link sap.ui.loader.config configuration}.
     * The resource will be loaded and executed which in turn will execute the top level `sap.ui.define` call.
     *
     * If the module ID was omitted from that call, it will be substituted by the ID that was used to request
     * the module. As a preparation step, the dependencies as well as their transitive dependencies, will be
     * loaded. Then, the module value (its export) will be determined: if a static value (object, literal) was
     * given as `vFactory`, that value will be the module value. If a function was given, that function will
     * be called (providing the module exports of the declared dependencies as parameters to the function) and
     * its return value will be used as module export value. The framework internally associates the resulting
     * value with the module ID and provides it to the original requester of the module. Whenever the module
     * is requested again, the same export value will be returned (modules are executed only once).
     *
     * Example:
     *  The following example defines a module, but doesn't hard code the module ID. If stored in a file 'sap/mylib/SomeClass.js',
     * it can be requested with the ID 'sap/mylib/SomeClass'.
     * ```javascript
     *
     *   sap.ui.define(['./Helper', 'sap/m/Bar'], function(Helper,Bar) {
     *
     *     // create a new class
     *     var SomeClass = function() {};
     *
     *     // add methods to its prototype
     *     SomeClass.prototype.foo = function() {
     *
     *         // use a function from the dependency 'Helper' in the same package (e.g. 'sap/mylib/Helper' )
     *         var mSettings = Helper.foo();
     *
     *         // create and return an sap.m.Bar (using its local name 'Bar')
     *         return new Bar(mSettings);
     *
     *     }
     *
     *     // return the class as module value
     *     return SomeClass;
     *
     *   });
     * ```
     *
     *
     * In another module or in an application HTML page, the {@link sap.ui.require} API can be used to load
     * the sap/mylib/Something module and to work with it:
     *
     *
     * ```javascript
     *
     * sap.ui.require(['sap/mylib/Something'], function(Something) {
     *
     *   // instantiate a Something and call foo() on it
     *   new Something().foo();
     *
     * });
     * ```
     *
     *
     * Module Name Syntax:
     *
     * `sap.ui.define` uses a simplified variant of the {@link jQuery.sap.getResourcePath unified resource name}
     * syntax for the module's own name as well as for its dependencies. The only difference to that syntax
     * is, that for `sap.ui.define` and `sap.ui.require`, the extension (which always would be '.js') has to
     * be omitted. Both methods always add this extension internally.
     *
     * As a convenience, the name of a dependency can start with the segment './' which will be replaced by
     * the name of the package that contains the currently defined module (relative name).
     *
     * It is best practice to omit the name of the defined module (first parameter) and to use relative names
     * for the dependencies whenever possible. This reduces the necessary configuration, simplifies renaming
     * of packages and allows to map them to a different namespace.
     *
     * Dependency to Modules:
     *
     * If a dependencies array is given, each entry represents the name of another module that the currently
     * defined module depends on. All dependency modules are loaded before the export of the currently defined
     * module is determined. The module export of each dependency module will be provided as a parameter to
     * a factory function, the order of the parameters will match the order of the modules in the dependencies
     * array.
     *
     * **Note:** The order in which the dependency modules are executed is **not** defined by the order
     * in the dependencies array! The execution order is affected by dependencies between the dependency
     * modules as well as by their current state (whether a module already has been loaded or not). Neither
     * module implementations nor dependents that require a module set must make any assumption about the execution
     * order (other than expressed by their dependencies).
     *
     * **Note:** A static module export (a literal provided to `sap.ui.define`) cannot depend on the module
     * exports of the dependency modules as it has to be calculated before the dependencies are resolved. As
     * an alternative, modules can define a factory function, calculate a static export value in that function,
     * potentially based on the dependencies, and return the result as module export value. The same approach
     * must be taken when the module export is supposed to be a function.
     *
     * Asynchronous Contract:
     *
     * `sap.ui.define` is designed to support real Asynchronous Module Definitions (AMD) in future, although
     * it internally still might use synchronous module loading, depending on configuration and context. However,
     * callers of `sap.ui.define` must never rely on any synchronous behavior that they might observe in a specific
     * test scenario.
     *
     * For example, callers of `sap.ui.define` must not use the module export value immediately after invoking
     * `sap.ui.define`:
     *
     *
     * ```javascript
     *
     *   // COUNTER EXAMPLE HOW __NOT__ TO DO IT
     *
     *   // define a class Something as AMD module
     *   sap.ui.define('Something', [], function() {
     *     var Something = function() {};
     *     return Something;
     *   });
     *
     *   // DON'T DO THAT!
     *   // accessing the class _synchronously_ after sap.ui.define was called
     *   new Something();
     *
     * ```
     *
     *
     * Applications that need to ensure synchronous module definition or synchronous loading of dependencies
     * **MUST** use the deprecated legacy APIs {@link jQuery.sap.declare} and {@link jQuery.sap.require}.
     *
     * (No) Global References:
     *
     * To be in line with AMD best practices, modules defined with `sap.ui.define` should not make any use of
     * global variables if those variables are also available as module exports. Instead, they should add dependencies
     * to those modules and use the corresponding parameter of the factory function to access the module exports.
     *
     * As the current programming model and the documentation of UI5 heavily rely on global names, there will
     * be a transition phase where UI5 enables AMD modules and local references to module exports in parallel
     * to the old global names. The fourth parameter of `sap.ui.define` has been added to support that transition
     * phase. When this parameter is set to true, the framework provides two additional features
     *
     *
     * 	 - Before the factory function is called, the existence of the global parent namespace for the current
     * 			module is ensured
     * 	 - The module export returned by the module's factory function will be automatically exported under
     * 			the global name which is derived from the ID of the module
     *
     * The parameter lets the framework know whether any of those two operations is needed or not. In future
     * versions of UI5, a central configuration option is planned to suppress those 'exports'.
     *
     * Third Party Modules: Although third party modules don't use UI5 APIs, they still can be listed as dependencies
     * in a `sap.ui.define` call. They will be requested and executed like UI5 modules, but to make their exports
     * available, so called ***shims*** have to be defined.
     *
     * Note that UI5 temporarily deactivates an existing AMD loader while it executes third party modules known
     * to support AMD. This sounds contradictorily at a first glance as UI5 wants to support AMD, but for now
     * it is necessary to fully support UI5 applications that rely on global names for such modules.
     *
     * For third-party modules that UI5 delivers (e.g. those in namespace `sap/ui/thirdparty/`), the necessary
     * shims are defined by UI5 itself by executing the private module `ui5loader-autoconfig.js` during bootstrap.
     *
     * Example:
     * ```javascript
     *
     *   // module 'Something' wants to use third party library 'URI.js'
     *   // It is packaged by UI5 as non-UI5-module 'sap/ui/thirdparty/URI'
     *   // the following shim helps UI5 to correctly load URI.js and to retrieve the module's export value
     *   // Apps don't have to define that shim, it is already applied by ui5loader-autconfig.js
     *   sap.ui.loader.config({
     *     shim: {
     *       'sap/ui/thirdparty/URI': {
     *          amd: true, // URI.js reacts on an AMD loader, this flag lets UI5 temp. disable such loaders
     *          exports: 'URI' // name of the global variable under which URI.js exports its module value
     *       }
     *     }
     *   });
     *
     *   // now the module can be retrieved like other modules
     *   sap.ui.define('Something', ['sap/ui/thirdparty/URI'], function(URIModuleValue) {
     *
     *     new URIModuleValue(...); // same as the global 'URI' name: new URI(...)
     *
     *     ...
     *   });
     * ```
     *
     *
     * Differences to Standard AMD:
     *
     * The current implementation of `sap.ui.define` differs from the AMD specification (https://github.com/amdjs/amdjs-api)
     * or from concrete AMD loaders like `requireJS` in several aspects:
     * 	 - The name `sap.ui.define` is different from the plain `define`. This has two reasons: first, it avoids
     * 			the impression that `sap.ui.define` is an exact implementation of an AMD loader. And second, it allows
     * 			the coexistence of an AMD loader (e.g. requireJS) and `sap.ui.define` in one application as long as UI5
     * 			or applications using UI5 are not fully prepared to run with an AMD loader. Note that the difference
     * 			of the API names also implies that the UI5 loader can't be used to load 'real' AMD modules as they expect
     * 			methods `define` and `require` to be available. Modules that use Unified Module Definition (UMD) syntax,
     * 			can be loaded, but only when no AMD loader is present or when they expose their export also to the global
     * 			namespace, even when an AMD loader is present (as e.g. jQuery does) or when a shim is defined for them
     * 			using the `amd:true` flag (see example above)
     * 	 - Depending on configuration and the current context, `sap.ui.define` loads the dependencies of a module
     * 			either synchronously using a sync XHR call + eval or asynchronously via script tags. The sync loading
     * 			is basically a tribute to the synchronous history of UI5. There's no way for a module developer to enforce
     * 			synchronous loading of the dependencies and on the long run, sync loading will be faded out. Applications
     * 			that need to ensure synchronous loading of dependencies **MUST** use the deprecated legacy APIs like
     * 			{@link jQuery.sap.require}.
     * 	 - `sap.ui.define` does not support plugins to use other file types, formats or protocols. It is not
     * 			planned to support this in future
     * 	 - `sap.ui.define` does not support absolute URLs as module names (dependencies) nor does it allow module
     * 			names that start with a slash. To refer to a module at an absolute URL, a resource root can be registered
     * 			that points to that URL (or to a prefix of it).
     * 	 - `sap.ui.define` does **not** support the 'sugar' of requireJS where CommonJS style dependency declarations
     * 			using `sap.ui.require("something")` are automagically converted into `sap.ui.define` dependencies before
     * 			executing the factory function.
     *
     * Limitations, Design Considerations:
     * 	 - **Limitation**: as dependency management is not supported for Non-UI5 modules, the only way to ensure
     * 			proper execution order for such modules currently is to rely on the order in the dependency array. Obviously,
     * 			this only works as long as `sap.ui.define` uses synchronous loading. It will be enhanced when asynchronous
     * 			loading is implemented.
     * 	 - It was discussed to enforce asynchronous execution of the module factory function (e.g. with a timeout
     * 			of 0). But this would have invalidated the current migration scenario where a sync `jQuery.sap.require`
     * 			call can load a `sap.ui.define`'ed module. If the module definition would not execute synchronously,
     * 			the synchronous contract of the require call would be broken (default behavior in existing UI5 applications)
     *
     * 	 - A single file must not contain multiple calls to `sap.ui.define`. Multiple calls currently are only
     * 			supported in the so called 'preload' files that the UI5 merge tooling produces. The exact details of
     * 			how this works might be changed in future implementations and are not part of the API contract
     * See:
     * 	https://github.com/amdjs/amdjs-api
     */
    function define(
      /**
       * List of dependencies of the module
       */
      aDependencies: (
        | keyof sap.IUI5DefineDependencyNames
        | (string & { IGNORE_ME?: never }))[],
      /**
       * The module export value or a function that calculates that value
       */
      vFactory: Function | any,
      /**
       * Whether an export to global names is required - should be used by SAP-owned code only
       */
      bExport?: boolean
    ): void;
    /**
     * @SINCE 1.27.0
     *
     * Defines a JavaScript module with its ID, its dependencies and a module export value or factory.
     *
     * The typical and only suggested usage of this method is to have one single, top level call to `sap.ui.define`
     * in one JavaScript resource (file). When a module is requested by its module ID for the first time, the
     * corresponding resource is determined from the ID and the current {@link sap.ui.loader.config configuration}.
     * The resource will be loaded and executed which in turn will execute the top level `sap.ui.define` call.
     *
     * If the module ID was omitted from that call, it will be substituted by the ID that was used to request
     * the module. As a preparation step, the dependencies as well as their transitive dependencies, will be
     * loaded. Then, the module value (its export) will be determined: if a static value (object, literal) was
     * given as `vFactory`, that value will be the module value. If a function was given, that function will
     * be called (providing the module exports of the declared dependencies as parameters to the function) and
     * its return value will be used as module export value. The framework internally associates the resulting
     * value with the module ID and provides it to the original requester of the module. Whenever the module
     * is requested again, the same export value will be returned (modules are executed only once).
     *
     * Example:
     *  The following example defines a module, but doesn't hard code the module ID. If stored in a file 'sap/mylib/SomeClass.js',
     * it can be requested with the ID 'sap/mylib/SomeClass'.
     * ```javascript
     *
     *   sap.ui.define(['./Helper', 'sap/m/Bar'], function(Helper,Bar) {
     *
     *     // create a new class
     *     var SomeClass = function() {};
     *
     *     // add methods to its prototype
     *     SomeClass.prototype.foo = function() {
     *
     *         // use a function from the dependency 'Helper' in the same package (e.g. 'sap/mylib/Helper' )
     *         var mSettings = Helper.foo();
     *
     *         // create and return an sap.m.Bar (using its local name 'Bar')
     *         return new Bar(mSettings);
     *
     *     }
     *
     *     // return the class as module value
     *     return SomeClass;
     *
     *   });
     * ```
     *
     *
     * In another module or in an application HTML page, the {@link sap.ui.require} API can be used to load
     * the sap/mylib/Something module and to work with it:
     *
     *
     * ```javascript
     *
     * sap.ui.require(['sap/mylib/Something'], function(Something) {
     *
     *   // instantiate a Something and call foo() on it
     *   new Something().foo();
     *
     * });
     * ```
     *
     *
     * Module Name Syntax:
     *
     * `sap.ui.define` uses a simplified variant of the {@link jQuery.sap.getResourcePath unified resource name}
     * syntax for the module's own name as well as for its dependencies. The only difference to that syntax
     * is, that for `sap.ui.define` and `sap.ui.require`, the extension (which always would be '.js') has to
     * be omitted. Both methods always add this extension internally.
     *
     * As a convenience, the name of a dependency can start with the segment './' which will be replaced by
     * the name of the package that contains the currently defined module (relative name).
     *
     * It is best practice to omit the name of the defined module (first parameter) and to use relative names
     * for the dependencies whenever possible. This reduces the necessary configuration, simplifies renaming
     * of packages and allows to map them to a different namespace.
     *
     * Dependency to Modules:
     *
     * If a dependencies array is given, each entry represents the name of another module that the currently
     * defined module depends on. All dependency modules are loaded before the export of the currently defined
     * module is determined. The module export of each dependency module will be provided as a parameter to
     * a factory function, the order of the parameters will match the order of the modules in the dependencies
     * array.
     *
     * **Note:** The order in which the dependency modules are executed is **not** defined by the order
     * in the dependencies array! The execution order is affected by dependencies between the dependency
     * modules as well as by their current state (whether a module already has been loaded or not). Neither
     * module implementations nor dependents that require a module set must make any assumption about the execution
     * order (other than expressed by their dependencies).
     *
     * **Note:** A static module export (a literal provided to `sap.ui.define`) cannot depend on the module
     * exports of the dependency modules as it has to be calculated before the dependencies are resolved. As
     * an alternative, modules can define a factory function, calculate a static export value in that function,
     * potentially based on the dependencies, and return the result as module export value. The same approach
     * must be taken when the module export is supposed to be a function.
     *
     * Asynchronous Contract:
     *
     * `sap.ui.define` is designed to support real Asynchronous Module Definitions (AMD) in future, although
     * it internally still might use synchronous module loading, depending on configuration and context. However,
     * callers of `sap.ui.define` must never rely on any synchronous behavior that they might observe in a specific
     * test scenario.
     *
     * For example, callers of `sap.ui.define` must not use the module export value immediately after invoking
     * `sap.ui.define`:
     *
     *
     * ```javascript
     *
     *   // COUNTER EXAMPLE HOW __NOT__ TO DO IT
     *
     *   // define a class Something as AMD module
     *   sap.ui.define('Something', [], function() {
     *     var Something = function() {};
     *     return Something;
     *   });
     *
     *   // DON'T DO THAT!
     *   // accessing the class _synchronously_ after sap.ui.define was called
     *   new Something();
     *
     * ```
     *
     *
     * Applications that need to ensure synchronous module definition or synchronous loading of dependencies
     * **MUST** use the deprecated legacy APIs {@link jQuery.sap.declare} and {@link jQuery.sap.require}.
     *
     * (No) Global References:
     *
     * To be in line with AMD best practices, modules defined with `sap.ui.define` should not make any use of
     * global variables if those variables are also available as module exports. Instead, they should add dependencies
     * to those modules and use the corresponding parameter of the factory function to access the module exports.
     *
     * As the current programming model and the documentation of UI5 heavily rely on global names, there will
     * be a transition phase where UI5 enables AMD modules and local references to module exports in parallel
     * to the old global names. The fourth parameter of `sap.ui.define` has been added to support that transition
     * phase. When this parameter is set to true, the framework provides two additional features
     *
     *
     * 	 - Before the factory function is called, the existence of the global parent namespace for the current
     * 			module is ensured
     * 	 - The module export returned by the module's factory function will be automatically exported under
     * 			the global name which is derived from the ID of the module
     *
     * The parameter lets the framework know whether any of those two operations is needed or not. In future
     * versions of UI5, a central configuration option is planned to suppress those 'exports'.
     *
     * Third Party Modules: Although third party modules don't use UI5 APIs, they still can be listed as dependencies
     * in a `sap.ui.define` call. They will be requested and executed like UI5 modules, but to make their exports
     * available, so called ***shims*** have to be defined.
     *
     * Note that UI5 temporarily deactivates an existing AMD loader while it executes third party modules known
     * to support AMD. This sounds contradictorily at a first glance as UI5 wants to support AMD, but for now
     * it is necessary to fully support UI5 applications that rely on global names for such modules.
     *
     * For third-party modules that UI5 delivers (e.g. those in namespace `sap/ui/thirdparty/`), the necessary
     * shims are defined by UI5 itself by executing the private module `ui5loader-autoconfig.js` during bootstrap.
     *
     * Example:
     * ```javascript
     *
     *   // module 'Something' wants to use third party library 'URI.js'
     *   // It is packaged by UI5 as non-UI5-module 'sap/ui/thirdparty/URI'
     *   // the following shim helps UI5 to correctly load URI.js and to retrieve the module's export value
     *   // Apps don't have to define that shim, it is already applied by ui5loader-autconfig.js
     *   sap.ui.loader.config({
     *     shim: {
     *       'sap/ui/thirdparty/URI': {
     *          amd: true, // URI.js reacts on an AMD loader, this flag lets UI5 temp. disable such loaders
     *          exports: 'URI' // name of the global variable under which URI.js exports its module value
     *       }
     *     }
     *   });
     *
     *   // now the module can be retrieved like other modules
     *   sap.ui.define('Something', ['sap/ui/thirdparty/URI'], function(URIModuleValue) {
     *
     *     new URIModuleValue(...); // same as the global 'URI' name: new URI(...)
     *
     *     ...
     *   });
     * ```
     *
     *
     * Differences to Standard AMD:
     *
     * The current implementation of `sap.ui.define` differs from the AMD specification (https://github.com/amdjs/amdjs-api)
     * or from concrete AMD loaders like `requireJS` in several aspects:
     * 	 - The name `sap.ui.define` is different from the plain `define`. This has two reasons: first, it avoids
     * 			the impression that `sap.ui.define` is an exact implementation of an AMD loader. And second, it allows
     * 			the coexistence of an AMD loader (e.g. requireJS) and `sap.ui.define` in one application as long as UI5
     * 			or applications using UI5 are not fully prepared to run with an AMD loader. Note that the difference
     * 			of the API names also implies that the UI5 loader can't be used to load 'real' AMD modules as they expect
     * 			methods `define` and `require` to be available. Modules that use Unified Module Definition (UMD) syntax,
     * 			can be loaded, but only when no AMD loader is present or when they expose their export also to the global
     * 			namespace, even when an AMD loader is present (as e.g. jQuery does) or when a shim is defined for them
     * 			using the `amd:true` flag (see example above)
     * 	 - Depending on configuration and the current context, `sap.ui.define` loads the dependencies of a module
     * 			either synchronously using a sync XHR call + eval or asynchronously via script tags. The sync loading
     * 			is basically a tribute to the synchronous history of UI5. There's no way for a module developer to enforce
     * 			synchronous loading of the dependencies and on the long run, sync loading will be faded out. Applications
     * 			that need to ensure synchronous loading of dependencies **MUST** use the deprecated legacy APIs like
     * 			{@link jQuery.sap.require}.
     * 	 - `sap.ui.define` does not support plugins to use other file types, formats or protocols. It is not
     * 			planned to support this in future
     * 	 - `sap.ui.define` does not support absolute URLs as module names (dependencies) nor does it allow module
     * 			names that start with a slash. To refer to a module at an absolute URL, a resource root can be registered
     * 			that points to that URL (or to a prefix of it).
     * 	 - `sap.ui.define` does **not** support the 'sugar' of requireJS where CommonJS style dependency declarations
     * 			using `sap.ui.require("something")` are automagically converted into `sap.ui.define` dependencies before
     * 			executing the factory function.
     *
     * Limitations, Design Considerations:
     * 	 - **Limitation**: as dependency management is not supported for Non-UI5 modules, the only way to ensure
     * 			proper execution order for such modules currently is to rely on the order in the dependency array. Obviously,
     * 			this only works as long as `sap.ui.define` uses synchronous loading. It will be enhanced when asynchronous
     * 			loading is implemented.
     * 	 - It was discussed to enforce asynchronous execution of the module factory function (e.g. with a timeout
     * 			of 0). But this would have invalidated the current migration scenario where a sync `jQuery.sap.require`
     * 			call can load a `sap.ui.define`'ed module. If the module definition would not execute synchronously,
     * 			the synchronous contract of the require call would be broken (default behavior in existing UI5 applications)
     *
     * 	 - A single file must not contain multiple calls to `sap.ui.define`. Multiple calls currently are only
     * 			supported in the so called 'preload' files that the UI5 merge tooling produces. The exact details of
     * 			how this works might be changed in future implementations and are not part of the API contract
     * See:
     * 	https://github.com/amdjs/amdjs-api
     */
    function define(
      /**
       * The module export value or a function that calculates that value
       */
      vFactory: Function | any,
      /**
       * Whether an export to global names is required - should be used by SAP-owned code only
       */
      bExport?: boolean
    ): void;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Instantiates an HTML-based Fragment.
     *
     * To instantiate a Fragment, call this method as: sap.ui.htmlfragment([sId], sFragmentName, [oController]);
     * The Fragment instance ID is optional and will be used as prefix for the ID of all contained controls.
     * If no ID is passed, controls will not be prefixed. The sFragmentName must correspond to an HTML Fragment
     * which can be loaded via the module system (fragmentName + ".fragment.html") and which defines the Fragment.
     * If oController is given, the methods referenced in the Fragment will be called on this controller. Note
     * that Fragments may require a Controller to be given and certain methods to be available.
     *
     * Advanced usage: To instantiate a Fragment and optionally directly give the HTML definition instead of
     * loading it from a file, call this method as: sap.ui.htmlfragment(oFragmentConfig, [oController]); The
     * oFragmentConfig object can either have a "fragmentName" or a "fragmentContent" property. fragmentContent
     * is optional and can hold the Fragment definition as XML string; if not given, fragmentName must be given
     * and the Fragment content definition is loaded by the module system. Again, if oController is given, the
     * methods referenced in the Fragment will be called on this controller.
     */
    function htmlfragment(
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired.)
       */
      vFragment: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.HTMLView.create HTMLView.create} instead
     *
     * Defines or creates an instance of a declarative HTML view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     *
     * 	 - View Definition `sap.ui.htmlview(sId, vView)`: Defines a view of the given name with the given implementation.
     * 			sId must be the views name, vView must be an object and can contain implementations for any of the hooks
     * 			provided by HTMLView
     * 	 - View Instantiation `sap.ui.htmlview(sId?, vView)`: Creates an instance of the view with the given
     * 			name (and id).
     *
     * Any other call signature will lead to a runtime error. If the id is omitted in the second variant, an
     * id will be created automatically.
     */
    function htmlview(
      /**
       * name or implementation of the view.
       */
      vView: {
        /**
         * defines how the view source is loaded and rendered later on
         */
        async?: boolean;
      }
    ): sap.ui.core.mvc.HTMLView | undefined;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Defines OR instantiates an HTML-based Fragment.
     *
     * To define a JS Fragment, call this method as: sap.ui.jsfragment(sName, oFragmentDefinition) Where: -
     * "sName" is the name by which this fragment can be found and instantiated. If defined in its own file,
     * in order to be found by the module loading system, the file location and name must correspond to sName
     * (path + file name must be: fragmentName + ".fragment.js"). - "oFragmentDefinition" is an object at least
     * holding the "createContent(oController)" method which defines the Fragment content. If given during instantiation,
     * the createContent method receives a Controller instance (otherwise oController is undefined) and the
     * return value must be one sap.ui.core.Control (which could have any number of children).
     *
     * To instantiate a JS Fragment, call this method as: sap.ui.jsfragment([sId], sFragmentName, [oController]);
     * The Fragment ID is optional (generated if not given) and the Fragment implementation CAN use it to make
     * contained controls unique (this depends on the implementation: some JS Fragments may choose not to support
     * multiple instances within one application and not use the ID prefixing). The sFragmentName must correspond
     * to a JS Fragment which can be loaded via the module system (fragmentName + ".fragment.js") and which
     * defines the Fragment. If oController is given, the methods referenced in the Fragment will be called
     * on this controller. Note that Fragments may require a Controller to be given and certain methods to be
     * available.
     */
    function jsfragment(
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired)
       */
      sFragmentName: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.JSONView.create JSONView.create} instead.
     *
     * Creates a JSON view of the given name and id.
     *
     * The `viewName` must either correspond to a JSON module that can be loaded via the module system (viewName
     * + suffix ".view.json") and which defines the view or it must be a configuration object for a view. The
     * configuration object can have a viewName, viewContent and a controller property. The viewName behaves
     * as described above, viewContent can hold the view description as JSON string or as object literal.
     *
     * **Note**: when an object literal is given, it might be modified during view construction.
     *
     * The controller property can hold a controller instance. If a controller instance is given, it overrides
     * the controller defined in the view.
     *
     * When property `async` is set to true, the view definition and the controller class (and its dependencies)
     * will be loaded asynchronously. Any controls used in the view might be loaded sync or async, depending
     * on the experimental runtime configuration option "xx-xml-processing". Even when the view definition is
     * provided as string or object tree, controller or controls might be loaded asynchronously. In any case,
     * a view instance will be returned synchronously by this factory API, but its content (control tree) might
     * appear only later. Also see {@link sap.ui.core.mvc.View#loaded}.
     *
     * Like with any other control, an id is optional and will be created when missing.
     */
    function jsonview(
      /**
       * name of a view resource or view configuration as described above.
       */
      vView: {
        /**
         * name of a view resource in module name notation (without suffix)
         */
        viewName?: string;
        /**
         * view definition as a JSON string or an object literal
         */
        viewContent?: string | object;
        /**
         * defines how the view source is loaded and rendered later on
         */
        async?: boolean;
        /**
         * controller to be used for this view instance
         */
        controller?: sap.ui.core.mvc.Controller;
      }
    ): sap.ui.core.mvc.JSONView;
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.JSView.create JSView.create} to create view instances;
     * for defining JavaScript views, there's no substitute yet and ***sap.ui.jsview*** still has to be used
     *
     * Defines or creates an instance of a JavaScript view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     * View Definition:
     * ```javascript
     *
     *   sap.ui.jsview(sId, vView);
     * ```
     *  Defines a view of the given name with the given implementation. `sId` must be the view's name, `vView`
     * must be an object and can contain implementations for any of the hooks provided by JSView.
     *
     * View Instantiation (deprecated):
     * ```javascript
     *
     *   var oView = sap.ui.jsview(vView);
     *   var oView = sap.ui.jsview(vView, bASync);
     *   var oView = sap.ui.jsview(sId, vView);
     *   var oView = sap.ui.jsview(sId, vView, bAsync);
     * ```
     *  Creates an instance of the view with the given name (and id). If no view implementation has been defined
     * for that view name, a JavaScript module with the same qualified name and with suffix `.view.js` will
     * be loaded (required) and executed. The module should register a view definition on execution (1st. variant
     * above).
     *
     * If `sId` is omitted, an ID will be created automatically.
     *
     * When `bAsync` has a truthy value, the view definition will be read asynchronously, if needed, but the
     * (incomplete) view instance will be returned immediately.
     *
     * **Note:** Using `sap.ui.jsview` for creating view instances has been deprecated, use {@link sap.ui.core.mvc.JSView.create
     * JSView.create} instead. `JSView.create` enforces asynchronous loading and can be used via an AMD reference,
     * it doesn't rely on a global name.
     *
     * **Note:** Any other call signature will lead to a runtime error.
     */
    function jsview(
      /**
       * name or implementation of the view.
       */
      vView: string | object,
      /**
       * defines how the view source is loaded and rendered later on (only relevant for instantiation, ignored
       * for everything else)
       */
      bAsync?: boolean
    ): sap.ui.core.mvc.JSView | undefined;
    /**
     * @deprecated (since 1.56) - use {@link sap.ui.core.mvc.XMLView} in combination with {@link topic:5ee619fc1370463ea674ee04b65ed83b
     * XML Templating} instead
     *
     * Defines or creates an instance of a template view.
     *
     * The behavior of this method depends on the signature of the call and on the current context.
     *
     *
     * 	 - View Definition `sap.ui.templateview(sId, vView)`: Defines a view of the given name with the given
     * 			implementation. sId must be the views name, vView must be an object and can contain implementations for
     * 			any of the hooks provided by templateview
     * 	 - View Instantiation `sap.ui.templateview(sId?, vView)`: Creates an instance of the view with the given
     * 			name (and id).
     *
     * Any other call signature will lead to a runtime error. If the id is omitted in the second variant, an
     * id will be created automatically.
     */
    function templateview(
      /**
       * name or implementation of the view.
       */
      vView: string | object
    ): sap.ui.core.mvc.TemplateView | undefined;
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.View.create View.create} instead
     *
     * Creates a view of the given type, name and with the given id.
     *
     * The `vView` configuration object can have the following properties for the view instantiation:
     * 	 - The ID `vView.id` specifies an ID for the View instance. If no ID is given, an ID will be generated.
     *
     * 	 - The view name `vView.viewName` corresponds to an XML module that can be loaded via the module system
     * 			(vView.viewName + suffix ".view.xml")
     * 	 - The controller instance `vView.controller` must be a valid controller implementation. The given controller
     * 			instance overrides the controller defined in the view definition
     * 	 - The view type `vView.type` specifies what kind of view will be instantiated. All valid view types
     * 			are listed in the enumeration sap.ui.core.mvc.ViewType.
     * 	 - The view data `vView.viewData` can hold user specific data. This data is available during the whole
     * 			lifecycle of the view and the controller
     * 	 - The view loading mode `vView.async` must be a boolean and defines if the view source is loaded synchronously
     * 			or asynchronously. In async mode, the view is rendered empty initially, and re-rendered with the loaded
     * 			view content.
     * 	 - `vView.preprocessors` can hold a map from the specified preprocessor type (e.g. "xml") to an array
     * 			of preprocessor configurations; each configuration consists of a `preprocessor` property (optional when
     * 			registered as on-demand preprocessor) and may contain further preprocessor-specific settings. The preprocessor
     * 			can be either a module name as string implementation of {@link sap.ui.core.mvc.View.Preprocessor} or
     * 			a function according to {@link sap.ui.core.mvc.View.Preprocessor.process}. Do not set properties starting
     * 			with underscore like `_sProperty` property, these are reserved for internal purposes. When several preprocessors
     * 			are provided for one hook, it has to be made sure that they do not conflict when being processed serially.
     *
     * **Note**: These preprocessors are only available to this instance. For global or on-demand availability
     * use {@link sap.ui.core.mvc.XMLView.registerPreprocessor}.
     *
     * **Note**: Please note that preprocessors in general are currently only available to XMLViews.
     *
     * **Note**: Preprocessors only work in async views and will be ignored when the view is instantiated in
     * sync mode by default, as this could have unexpected side effects. You may override this behaviour by
     * setting the bSyncSupport flag of the preprocessor to true.
     */
    function view(
      /**
       * id of the newly created view, only allowed for instance creation
       */
      sId: string,
      /**
       * Specifies what kind of view will be instantiated. All valid view types are listed in the enumeration
       * {@link sap.ui.core.mvc.ViewType}.
       */
      sType: any
    ): sap.ui.core.mvc.View;
    /**
     * @deprecated (since 1.58) - use {@link sap.ui.core.Fragment.load} instead
     *
     * Instantiates an XML-based Fragment.
     *
     * To instantiate a Fragment, call this method as: sap.ui.xmlfragment([sId], sFragmentName, [oController]);
     * The Fragment instance ID is optional and will be used as prefix for the ID of all contained controls.
     * If no ID is passed, controls will not be prefixed. The sFragmentName must correspond to an XML Fragment
     * which can be loaded via the module system (fragmentName + ".fragment.xml") and which defines the Fragment.
     * If oController is given, the methods referenced in the Fragment will be called on this controller. Note
     * that Fragments may require a Controller to be given and certain methods to be available.
     *
     * Advanced usage: To instantiate a Fragment and optionally directly give the XML definition instead of
     * loading it from a file, call this method as: sap.ui.xmlfragment(oFragmentConfig, [oController]); The
     * oFragmentConfig object can either have a "fragmentName" or a "fragmentContent" property. fragmentContent
     * is optional and can hold the Fragment definition as XML string; if not given, fragmentName must be given
     * and the Fragment content definition is loaded by the module system. Again, if oController is given, the
     * methods referenced in the Fragment will be called on this controller.
     */
    function xmlfragment(
      /**
       * name of the Fragment (or Fragment configuration as described above, in this case no sId may be given.
       * Instead give the id inside the config object, if desired)
       */
      vFragment: string | object,
      /**
       * a Controller to be used for event handlers in the Fragment
       */
      oController?: sap.ui.core.mvc.Controller
    ): sap.ui.core.Control | sap.ui.core.Control[];
    /**
     * @deprecated (since 1.56) - Use {@link sap.ui.core.mvc.XMLView.create XMLView.create} instead
     *
     * Instantiates an XMLView of the given name and with the given ID.
     *
     * The `vView` can either be the name of the module that contains the view definition or it can be a configuration
     * object with properties `viewName`, `viewContent` and a `controller` property (more properties are described
     * in the parameters section below).
     *
     * If a `viewName` is given, it behaves the same as when `vView` is a string: the named resource will be
     * loaded and parsed as XML. Alternatively, an already loaded view definition can be provided as `viewContent`,
     * either as XML string or as an already parsed XML document. Exactly one of `viewName` and `viewContent`
     * must be given, if none or both are given, an error will be reported. The `controller` property is optional
     * and can hold a controller instance. When given, it overrides the controller class defined in the view
     * definition.
     *
     * When property `async` is set to true, the view definition and the controller class (and its dependencies)
     * will be loaded asynchronously. Any controls used in the view might be loaded sync or async, this depends
     * on the experimental runtime configuration option "xx-xml-processing". Even when the view definition is
     * provided as string or XML Document, controller or controls might be loaded asynchronously. In any case
     * a view instance will be returned synchronously by this factory API, but its content (control tree) might
     * appear only later. Also see {@link sap.ui.core.mvc.View#loaded}.
     *
     * **Note**: If an XML document is given, it might be modified during view construction.
     *
     * **Note**: On root level, you can only define content for the default aggregation, e.g. without adding
     * the `<content>` tag. If you want to specify content for another aggregation of a view like `dependents`,
     * place it in a child control's dependents aggregation or add it by using {@link sap.ui.core.mvc.XMLView#addDependent}.
     *
     * **Note**: If you enable caching, you need to take care of the invalidation via keys. Automatic invalidation
     * takes only place if the UI5 version or the component descriptor (manifest.json) change. This is still
     * an experimental feature and may experience slight changes of the invalidation parameters or the cache
     * key format.
     *
     * Like with any other control, `sId` is optional and an ID will be created automatically.
     */
    function xmlview(
      /**
       * Name of the view or a view configuration object as described above
       */
      vView: {
        /**
         * Name of the view resource in module name notation (without suffix)
         */
        viewName?: string;
        /**
         * XML string or XML document that defines the view
         */
        viewContent?: string | Document;
        /**
         * Defines how the view source is loaded and rendered later on
         */
        async?: boolean;
        /**
         * Cache configuration, only for `async` views; caching gets active when this object is provided with vView.cache.keys
         * array; keys are used to store data in the cache and for invalidation of the cache
         */
        cache?: {
          /**
           * Array with strings or Promises resolving with strings
           */
          keys?: any;
        };

        /**
         * Preprocessors configuration, see {@link sap.ui.core.mvc.View}
         */
        preprocessors?: object;
        /**
         * Controller instance to be used for this view
         */
        controller?: sap.ui.core.mvc.Controller;
      }
    ): sap.ui.core.mvc.XMLView;
    /**
     * SAPUI5 base classes
     */
    namespace base {
      /**
       * Contract for objects that can be pooled by ObjectPool
       */
      interface Poolable {
        /**
         * Called by the object pool when this instance will be actived for a caller. The same method will be called
         * after a new instance has been created by an otherwise exhausted pool.
         *
         * If the caller provided any arguments to {@link sap.ui.base.ObjectPool#borrowObject} all arguments will
         * be propagated to this method.
         */
        init(): void;
        /**
         * Called by the object pool when an instance is returned to the pool. While no specific implementation
         * is required, poolable objects in general should clean all caller specific state (set to null) in this
         * method to avoid memory leaks and to enforce garbage collection of the caller state.
         */
        reset(): void;
      }

      interface ManagedObjectOpts {
        /**
         * Fired after a new value for a bound property has been propagated to the model. Only fired, when the binding
         * uses a data type.
         */
        validationSuccess?: Function;

        /**
         * Fired when a new value for a bound property should have been propagated to the model, but validating
         * the value failed with an exception.
         */
        validationError?: Function;

        /**
         * Fired when a new value for a bound property should have been propagated to the model, but parsing the
         * value failed with an exception.
         */
        parseError?: Function;

        /**
         * Fired when a new value for a bound property should have been propagated from the model, but formatting
         * the value failed with an exception.
         */
        formatError?: Function;

        /**
         * Fired when models or contexts are changed on this object (either by calling setModel/setBindingContext
         * or due to propagation)
         */
        modelContextChange?: Function;
      }
      /**
       * @SINCE 0.9.0
       *
       * Represents the type of properties in a `ManagedObject` class.
       *
       * Each type provides some metadata like its {@link #getName qualified name} or its {@link #getBaseType
       * base type} in case of a derived type. Array types provide information about the allowed {@link #getComponentType
       * type of components} in an array, enumeration types inform about the set of their allowed {@link #getEnumValues
       * keys and values}.
       *
       * Each type has a method to {@link #isValid check whether a value is valid} for a property of that type.
       *
       * Already defined types can be looked up by calling {@link #.getType DataType.getType}, new types can only
       * be created by calling the factory method {@link #.createType DataType.createType}, calling the constructor
       * will throw an error.
       */
      class DataType {
        /**/
        constructor();

        /**
         * Derives a new type from a given base type.
         *
         * Example:
         *
         * ```javascript
         *
         *
         *   var fooType = DataType.createType('foo', {
         *       isValid : function(vValue) {
         *           return /^(foo(bar)?)$/.test(vValue);
         *       }
         *   }, DataType.getType('string'));
         *
         *   fooType.isValid('foo'); // true
         *   fooType.isValid('foobar'); // true
         *   fooType.isValid('==foobar=='); // false
         *
         * ```
         *
         *
         * If `mSettings` contains an implementation for `isValid`, then the validity check of the newly created
         * type will first execute the check of the base type and then call the given `isValid` function.
         *
         * Array types and enumeration types cannot be created with this method. They're created on-the-fly by {@link
         * #.getType DataType.getType} when such a type is looked up.
         *
         * **Note:** The creation of new primitive types is not supported. When a type is created without a base
         * type, it is automatically derived from the primitive type `any`.
         *
         * **Note:** If a type has to be used in classes tagged with `@ui5-metamodel`, then the implementation of
         * `isValid